To implement the requested features in your LandIQ app, follow these step-by-step instructions. These assume you're working in Replit's shell for installations and editing files directly. The changes focus on the frontend (`client/src/components/map-parcel-picker.tsx`) for map enhancements and the backend (`server/routes.ts` and `server/services/csr2.ts`) for the CSR2 average calculation. You'll need to install a few dependencies first.

I've structured this as clear, copy-pasteable code blocks with explanations. Test incrementally (e.g., run `npm run dev` or Replit's run button after changes).

### Step 1: Install Dependencies
In your Replit shell (or via package.json and `npm install`), run these in the respective directories:

- In `/client`:
  ```
  npm install @mapbox/mapbox-gl-draw @turf/turf
  ```

- In `/server`:
  ```
  npm install @terraformer/wkt
  ```

These add:
- `@mapbox/mapbox-gl-draw`: For user-drawn polygons (compatible with MapLibre GL).
- `@turf/turf`: For calculating polygon area in acres.
- `@terraformer/wkt`: For converting GeoJSON polygons to WKT format (required for the USDA soil query).

### Step 2: Add Parcel Outlines and Ownership Data to the Map
Edit `client/src/components/map-parcel-picker.tsx`. This adds a GeoJSON source and layer for Iowa parcels from the ArcGIS FeatureServer. Parcels load dynamically based on map bounds and zoom level (only at zoom > 12 to avoid performance issues, as the service limits 2000 features per query). On click, a popup shows ownership data (e.g., deed holder, parcel number).

Add/import these at the top (after existing imports):
```tsx
import maplibregl from 'maplibre-gl';
```

Then, in your map initialization function (after `const map = new maplibregl.Map({...})`), add this inside the `map.on('load', () => { ... })` block:
```tsx
// Add source for parcels (initially empty)
map.addSource('parcels', {
  type: 'geojson',
  data: { type: 'FeatureCollection', features: [] }
});

// Add outline layer for parcels
map.addLayer({
  id: 'parcels-outline',
  type: 'line',
  source: 'parcels',
  paint: {
    'line-color': '#0000FF', // Blue outlines
    'line-width': 1,
    'line-opacity': 0.8
  }
});

// Function to load parcels based on current bounds
const loadParcels = async () => {
  if (map.getZoom() <= 12) {
    // Clear data if zoomed out
    map.getSource('parcels').setData({ type: 'FeatureCollection', features: [] });
    return;
  }

  const bounds = map.getBounds();
  const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()].join(',');
  const url = `https://services3.arcgis.com/kd9gaiUExYqUbnoq/arcgis/rest/services/Iowa_Parcels_2017/FeatureServer/0/query?where=1%3D1&outFields=PARCELNUMB,DEEDHOLDER,PARCELCLAS&geometry=${bbox}&geometryType=esriGeometryEnvelope&inSR=4326&spatialRel=esriSpatialRelIntersects&returnGeometry=true&f=geojson`;

  try {
    const response = await fetch(url);
    const data = await response.json();
    if (data.features && data.features.length > 0 && data.features.length <= 2000) {
      map.getSource('parcels').setData(data);
    } else {
      // Handle too many features or empty (e.g., alert user to zoom in)
      console.warn('Too many or no parcels in view; zoom in for details.');
      map.getSource('parcels').setData({ type: 'FeatureCollection', features: [] });
    }
  } catch (error) {
    console.error('Error loading parcels:', error);
  }
};

// Load parcels on initial load and after moves
loadParcels();
map.on('moveend', loadParcels);

// Show ownership popup on click
map.on('click', 'parcels-outline', (e) => {
  if (e.features && e.features.length > 0) {
    const props = e.features[0].properties;
    const html = `
      <strong>Owner:</strong> ${props.DEEDHOLDER || 'Unknown'}<br>
      <strong>Parcel Number:</strong> ${props.PARCELNUMB || 'N/A'}<br>
      <strong>Class:</strong> ${props.PARCELCLAS || 'N/A'}
    `;
    new maplibregl.Popup()
      .setLngLat(e.lngLat)
      .setHTML(html)
      .addTo(map);
  }
});

// Make the layer interactive
map.on('mouseenter', 'parcels-outline', () => {
  map.getCanvas().style.cursor = 'pointer';
});
map.on('mouseleave', 'parcels-outline', () => {
  map.getCanvas().style.cursor = '';
});
```

### Step 3: Add User-Drawn Polygon with Area Calculation and CSR2 Average
Still in `client/src/components/map-parcel-picker.tsx`. This adds drawing controls using Mapbox GL Draw. When a polygon is drawn, it automatically calculates acres using Turf.js and fetches the average CSR2 from a new backend endpoint. Display results in a popup or integrate into your ValuationPipeline/Report components (e.g., via state or props).

Add these imports at the top:
```tsx
import MapboxDraw from '@mapbox/mapbox-gl-draw';
import * as turf from '@turf/turf';
```

Then, after map initialization (in the `useEffect` or init block):
```tsx
const draw = new MapboxDraw({
  displayControlsDefault: false, // Hide default controls; we'll add a custom button
  controls: {
    polygon: true,
    trash: true
  }
});
map.addControl(draw);

// Event for when polygon is created
map.on('draw.create', async (e) => {
  const polygon = e.features[0];

  // Calculate acres
  const areaSqM = turf.area(polygon);
  const acres = (areaSqM / 4046.86).toFixed(2); // 1 acre = 4046.86 sq m

  // Fetch average CSR2 from backend
  try {
    const response = await fetch('/api/average-csr2', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ polygon: polygon.geometry })
    });
    const data = await response.json();
    const avgCSR2 = data.average.toFixed(2);

    // Display results (e.g., in popup; adapt to your UI, like setting state)
    const html = `
      <strong>Acres:</strong> ${acres}<br>
      <strong>Average CSR2:</strong> ${avgCSR2}
    `;
    new maplibregl.Popup()
      .setLngLat(map.getCenter()) // Or centroid of polygon
      .setHTML(html)
      .addTo(map);

    // Optional: Integrate into valuation (e.g., update form state)
    // yourStateUpdater({ acres, avgCSR2 });

  } catch (error) {
    console.error('Error calculating CSR2:', error);
    // Handle error in UI
  }
});
```

Add a button in your JSX (e.g., in the map controls UI) to start drawing:
```tsx
<button
  onClick={() => draw.changeMode('draw_polygon')}
  className="bg-blue-500 text-white px-4 py-2 rounded"
>
  Draw Custom Polygon
</button>
```

### Step 4: Add Backend Endpoint for Average CSR2 Calculation
Edit `server/routes.ts` (or your main app file). Add this route:
```ts
import { calculateAverageCSR2 } from './services/csr2'; // Adjust path if needed

app.post('/api/average-csr2', async (req, res) => {
  const { polygon } = req.body; // GeoJSON Polygon
  try {
    const average = await calculateAverageCSR2(polygon);
    res.json({ average });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Failed to calculate average CSR2' });
  }
});
```

Now, in `server/services/csr2.ts`, add this function (extend existing CSR2 logic if it fits; this uses USDA's Soil Data Access API for real SSURGO data, including CSR2):
```ts
import { toWKT } from '@terraformer/wkt';

export async function calculateAverageCSR2(polygon: any): Promise<number> {
  const wkt = toWKT(polygon); // Convert GeoJSON to WKT

  const sql = `
    WITH aoi AS (
      SELECT mukey, SUM(ACRES) AS total_acres
      FROM SDA_Get_Mukey_from_intersection_with_WktWgs84('${wkt}')
      GROUP BY mukey
    ),
    csr2 AS (
      SELECT mu.mukey,
             SUM(c.comppct_r * CAST(ci.interphr AS FLOAT)) / SUM(c.comppct_r) AS weighted_csr2
      FROM mapunit mu
      INNER JOIN component c ON mu.mukey = c.mukey
      INNER JOIN cointerp ci ON c.cokey = ci.cokey
      WHERE ci.rulename = 'Iowa Corn Suitability Rating CSR2 (IA)'
        AND c.majcompflag = 'Yes'
      GROUP BY mu.mukey
    )
    SELECT 
      CASE 
        WHEN SUM(aoi.total_acres) = 0 THEN 0
        ELSE SUM(aoi.total_acres * csr2.weighted_csr2) / SUM(aoi.total_acres) 
      END AS average_csr2
    FROM aoi 
    INNER JOIN csr2 ON aoi.mukey = csr2.mukey
  `;

  const response = await fetch('https://SDMDataAccess.nrcs.usda.gov/Tabular/SDMTabularService/post.rest', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query: sql, format: 'JSON+COLUMNNAME' })
  });

  const data = await response.json();
  if (!data.Table || data.Table.length === 0) {
    throw new Error('No CSR2 data found for polygon');
  }

  return parseFloat(data.Table[0][0]); // Average CSR2
}
```

### Step 5: Testing and Integration
- Restart your app in Replit.
- Navigate to the map page, zoom into Iowa (>12), and pan—parcels should appear with clickable popups.
- Click "Draw Custom Polygon", draw on the map, and finish (double-click or via draw controls)—it should show acres and average CSR2.
- Integrate results into your PropertyForm or ValuationReport (e.g., via React Query mutations).
- Note: The ArcGIS data is from 2017; for production, monitor query limits. CSR2 queries respect USDA APIs (no key needed, but rate-limit if high-traffic).

If issues arise (e.g., CORS, API errors), debug with console logs or add caching in backend.